unit TwoVehicles;

interface

 uses
 sysUtils, Typez, vehicles, customers, math;
  //function assignCtoV(clist:custarray):custarray;
  procedure clustering(clist:custarray);
  procedure clock_counter(ve:vearray);
  procedure to_radial(clist:custarray);
  function exp_dem(cu:customer): real;

 var
 vlist: vearray;

implementation

procedure clustering(clist:custarray);
var
i:integer;
aux1,aux2: custarray;
begin
    setlength(vlist,2);
    setlength(aux1,1);
    setlength(aux2,1);
    aux1[0]:=dep;
    aux2[0]:=dep;

    for I := 1 to length(clist) - 1 do
    if clist[i].xcoor<clist[i].ycoor then
    begin
        setlength(aux1, length(aux1)+1);
        aux1[length(aux1)-1]:=clist[i];
    end
    else
    begin
        setlength(aux2, length(aux2)+1);
        aux2[length(aux2)-1]:=clist[i];
    end;

    vlist[0]:= vehicle.create(1,aux1);
    vlist[1]:=vehicle.Create(2,aux2);

end;

function angle(clist:custarray):polararray;
var
i:integer;
ang:real;
polar:polararray;
begin
     setlength(polararray,n-1);
     for i := 1 to n - 1 do
     begin
     ang:= arctan(abs(clist[i].ycoor/clist[i].xcoor));
     if clist[i].ycoor<0 then
      if clist[i].xcoor<0 then
      begin
        ang:=ang+PI;
      end
      else ang:=2*PI - ang;
     if clist[i].ycoor>0 then
      if clist[i].xcoor<0 then
      begin
        ang:=PI-ang;
      end;
      polar[i-1].ID:=clist[i].ID;
      polar[i-1].ang:=ang;
     end;
     result:=polar;
end;

procedure SortPArray(parray:polararray);
var
p1,p2: Integer;
temp : polar_coor;
begin
for p1 := 0 to Length(parray) - 1 do
  for p2 := 0 to length(parray) - 2 do
  begin
    if (parray[p2].ang > parray[p2+1].ang) then
    begin
      temp := parray[p2];
      parray[p2] := parray[p2+1];
      parray[p2+1] := temp;
    end;
  end;
end;

function exp_dem(cu:customer): real;
begin
  result:=(cu.dem.dmax+cu.dem.dmin)/2;
end;

procedure clock_counter(ve:vearray);
begin

end;
end.
