unit Trio;

interface

uses
SysUtils, math, expectedlen, Classes, Customers, Demands,
  Pairs,flex, Subroutines, Vehicles, States, Typez, Rollout;

implementation

function simulatet(var tr:trio):ccustarray;
var
cstate:state;
nnode:custarray;
l,anode,bnode:customer;
d:barray;
t,ad,bd,cd:boolean;
i,j,cq:integer;
acost,bcost,ccost,dcost,ec:real;
sf,nexxt,ecost:rearray;
nseq:ccustarray;

begin

  cstate:= state.create(dep,q);
  cstate.dems:= dems;
  setlength(nnode,3);
  setlength(d,3);
  setlength(nexxt,3);
  setlength(ecost,3);
  setlength(fseq,3);
  setlength(nseq,3);
  setlength(sf,3);
  setlength(fs,3);
  t:=false;
  
  for i := 0 to 2 do
    begin
      setlength(nseq[i],length(tr.ve[i].custs));
      nseq[i]:=tri.ve[i].custs;
      mark_visited(nseq[i],dep);
      setlength(nseq[i],length(nseq[i])-1);

      //Define first node
      nseq[i]:= firstnode(nseq[i],pa.line,ec);
      ecost[i]:= ec;
      descrb(cstate);
      apriori_length(nseq[i],cstate);

      nnode[i]:=nseq[i,0];
      nexxt[i]:=dist[0,nnode[i].id];
      mark_visited(nseq[i],nnode[i]);
      setlength(nseq[i],length(nseq[i])-1);
      fs[i]:=-1;
    end;

  Writeln(' ');
  Writeln('Rolling out...');

  repeat //Define next customer
  begin

    //Who's next??
    i:=0;
    sf[i]:= sofar(fseq[i])+nexxt[i];
    sf[i+1]:= sofar(fseq[i+1])+nexxt[i+1];
    if ((sf[i]>sf[i+1]) and (length(nseq[i+1])>0)) or (length(nseq[i])=0)then i:=1;

    //Update the state
    cstate:= updte(pa,cstate,nnode[i],d[i],i);
    descrb(cstate);

    fs[i]:=fs[i]+1;
    setlength(fseq[i],fs[i]+1);
    fseq[i,fs[i]]:=nnode[i];

    if length(nseq[i])>0 then
    begin
      acost:=0;
      bcost:=0;
      ccost:=0;

      //No switch
      anode:=roll(nseq[i],l,pa.ve[i].cp,pa.ve[i].cq,ad,acost);

      if sf[i]>di[i]/2 then
      begin
        //Switch
        bnode:=roll(nseq[c(i+1,2)],l,pa.ve[i].cp,pa.ve[i].cq,bd,bcost);
        for j := nnode[c(i+1,2)].dem.dmin to nnode[c(i+1,2)].dem.dmax do
        begin
          cq:= capac(pa.ve[c(i+1,2)].cq,j,d[c(i+1,2)]);
          roll(nseq[c(i+1,2)],l,pa.ve[c(i+1,2)].cp,cq,cd,dcost);
          ccost:=ccost+dcost;
        end;

      //Switch??
        if (bcost+ccost/nnode[c(i+1,2)].dem.num)< (acost+ecost[c(i+1,2)]) then
        begin
          nnode[i]:=bnode;
          ecost[i]:=bcost;
          d[i]:=bd;
          nexxt[i]:=next(pa.ve[i].cp,bnode,bd);
          switch(nseq);
        end
        else
          begin
            nnode[i]:=anode;
            ecost[i]:=acost;
            d[i]:=ad;
            nexxt[i]:=next(pa.ve[i].cp,anode,ad);
          end;
      end
      else
      begin
         nnode[i]:=anode;
         ecost[i]:=acost;
         d[i]:=ad;
         nexxt[i]:=next(pa.ve[i].cp,anode,ad);
      end;

    mark_visited(nseq[i],nnode[i]);
    setlength(nseq[i],length(nseq[i])-1);

    //Last??
    if not((length(nseq[c(i+1,2)])>0) or (length(nseq[i])>0)) then
    begin
      cstate:= updte(pa,cstate,nnode[i],d[i],i);
      descrb(cstate);
      fs[i]:=fs[i]+1;
      setlength(fseq[i],fs[i]+1);
      fseq[i,fs[i]]:=nnode[i];

      cstate:= updte(pa,cstate,nnode[c(i+1,2)],d[c(i+1,2)],c(i+1,2));
      descrb(cstate);
      fs[c(i+1,2)]:=fs[c(i+1,2)]+1;
      setlength(fseq[c(i+1,2)],fs[c(i+1,2)]+1);
      fseq[c(i+1,2),fs[c(i+1,2)]]:=nnode[c(i+1,2)];

      t:=true;
    end;
  end;
  end;
  until t=true;

  result:=fseq;

end;

end.
